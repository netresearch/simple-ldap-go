//go:build !integration

package ldap

import (
	"context"
	"fmt"
	"log/slog"
	"runtime"
	"sync"
	"testing"
	"time"
)

// BenchmarkLDAPClientOperations benchmarks core LDAP client operations
func BenchmarkLDAPClientOperations(b *testing.B) {
	b.Run("NewLDAP", func(b *testing.B) {
		config := &Config{
			Server: "ldap://test:389",
			BaseDN: "dc=example,dc=com",
		}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			client, err := New(config, "user", "pass")
			_ = client
			_ = err
		}
	})

	b.Run("NewLDAPWithLogger", func(b *testing.B) {
		config := &Config{
			Server: "ldap://test:389",
			BaseDN: "dc=example,dc=com",
			Logger: slog.Default(),
		}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			client, err := New(config, "user", "pass")
			_ = client
			_ = err
		}
	})

	b.Run("ConfigCreation", func(b *testing.B) {
		configs := []*Config{
			{Server: "ldap://test:389", BaseDN: "dc=example,dc=com"},
			{Server: "ldaps://test:636", BaseDN: "dc=test,dc=org"},
			{Server: "ldap://test2:389", BaseDN: "dc=test2,dc=org"},
		}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			config := configs[i%len(configs)]
			_ = config.Server
			_ = config.BaseDN
		}
	})
}

// BenchmarkConnectionPoolOperations benchmarks connection pool operations
func BenchmarkConnectionPoolOperations(b *testing.B) {
	b.Run("PoolCreation", func(b *testing.B) {
		config := &Config{
			Server: "ldap://test:389",
			BaseDN: "dc=example,dc=com",
			Pool: &PoolConfig{
				MaxConnections: 10,
				MaxIdleTime: 30 * time.Minute,
			},
		}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			pool := NewConnectionPool(config)
			_ = pool
		}
	})

	b.Run("ConnectionAcquisition", func(b *testing.B) {
		mock := NewMockLDAPConn()
		pool := &ConnectionPool{
			config: &Config{
				Pool: &PoolConfig{MaxConnections: 10},
			},
			pool:   make(chan LDAPConnection, 10),
			mutex:  &sync.RWMutex{},
		}

		// Pre-fill pool
		for i := 0; i < 5; i++ {
			pool.pool <- mock
		}

		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			for pb.Next() {
				ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
				conn, err := pool.GetConnection(ctx)
				if err == nil && conn != nil {
					pool.ReturnConnection(conn)
				}
				cancel()
			}
		})
	})

	b.Run("PoolStatistics", func(b *testing.B) {
		pool := &ConnectionPool{
			config: &Config{
				Pool: &PoolConfig{MaxConnections: 10},
			},
			stats:  &PoolStats{},
			mutex:  &sync.RWMutex{},
		}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			stats := pool.GetStats()
			_ = stats
		}
	})
}

// BenchmarkUserOperations benchmarks user-related operations
func BenchmarkUserOperations(b *testing.B) {
	mock := NewMockLDAPConn()
	SetupTestUsersAndGroups(mock)

	client := &LDAP{
		config: &Config{
			Server: "ldap://test:389",
			BaseDN: "dc=example,dc=com",
		},
		logger: slog.Default(),
	}

	b.Run("FindUserByUsername", func(b *testing.B) {
		usernames := []string{"admin", "user1", "user2", "nonexistent"}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			username := usernames[i%len(usernames)]
			user, err := client.FindUserByUsername(context.Background(), username)
			_ = user
			_ = err
		}
	})

	b.Run("FindUserByDN", func(b *testing.B) {
		userDNs := []string{
			"cn=admin,ou=users,dc=example,dc=com",
			"cn=user1,ou=users,dc=example,dc=com",
			"cn=nonexistent,ou=users,dc=example,dc=com",
		}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			userDN := userDNs[i%len(userDNs)]
			user, err := client.FindUserByDN(context.Background(), userDN)
			_ = user
			_ = err
		}
	})

	b.Run("GetUserGroups", func(b *testing.B) {
		userDN := "cn=admin,ou=users,dc=example,dc=com"

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			groups, err := client.GetUserGroups(context.Background(), userDN)
			_ = groups
			_ = err
		}
	})

	b.Run("AuthenticateUser", func(b *testing.B) {
		credentials := []struct {
			username string
			password string
		}{
			{"admin", "password"},
			{"user1", "password"},
			{"invalid", "wrong"},
		}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			cred := credentials[i%len(credentials)]
			success, err := client.AuthenticateUser(context.Background(), cred.username, cred.password)
			_ = success
			_ = err
		}
	})
}

// BenchmarkGroupOperations benchmarks group-related operations
func BenchmarkGroupOperations(b *testing.B) {
	mock := NewMockLDAPConn()
	SetupTestUsersAndGroups(mock)

	client := &LDAP{
		config: &Config{
			Server: "ldap://test:389",
			BaseDN: "dc=example,dc=com",
		},
		logger: slog.Default(),
	}

	b.Run("FindGroupByName", func(b *testing.B) {
		groupNames := []string{"admins", "users", "developers", "nonexistent"}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			groupName := groupNames[i%len(groupNames)]
			group, err := client.FindGroupByName(context.Background(), groupName)
			_ = group
			_ = err
		}
	})

	b.Run("GetGroupMembers", func(b *testing.B) {
		groupDN := "cn=admins,ou=groups,dc=example,dc=com"

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			members, err := client.GetGroupMembers(context.Background(), groupDN)
			_ = members
			_ = err
		}
	})

	b.Run("IsUserInGroup", func(b *testing.B) {
		userDN := "cn=admin,ou=users,dc=example,dc=com"
		groupDNs := []string{
			"cn=admins,ou=groups,dc=example,dc=com",
			"cn=users,ou=groups,dc=example,dc=com",
			"cn=nonexistent,ou=groups,dc=example,dc=com",
		}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			groupDN := groupDNs[i%len(groupDNs)]
			isMember, err := client.IsUserInGroup(context.Background(), userDN, groupDN)
			_ = isMember
			_ = err
		}
	})

	b.Run("SearchGroups", func(b *testing.B) {
		filters := []string{
			"(objectClass=group)",
			"(cn=admin*)",
			"(&(objectClass=group)(member=cn=admin,ou=users,dc=example,dc=com))",
		}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			filter := filters[i%len(filters)]
			groups, err := client.SearchGroups(context.Background(), filter)
			_ = groups
			_ = err
		}
	})
}

// BenchmarkSearchOperations benchmarks search operations
func BenchmarkSearchOperations(b *testing.B) {
	mock := NewMockLDAPConn()
	SetupTestUsersAndGroups(mock)

	client := &LDAP{
		config: &Config{
			Server: "ldap://test:389",
			BaseDN: "dc=example,dc=com",
		},
		logger: slog.Default(),
	}

	b.Run("SearchUsers", func(b *testing.B) {
		filters := []string{
			"(objectClass=user)",
			"(cn=admin*)",
			"(mail=*@example.com)",
			"(&(objectClass=user)(userAccountControl=512))",
		}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			filter := filters[i%len(filters)]
			users, err := client.SearchUsers(context.Background(), filter)
			_ = users
			_ = err
		}
	})

	b.Run("SearchWithScope", func(b *testing.B) {
		scopes := []int{0, 1, 2} // Base, OneLevel, Subtree

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			scope := scopes[i%len(scopes)]
			results, err := client.SearchWithScope(
				context.Background(),
				"ou=users,dc=example,dc=com",
				scope,
				"(objectClass=user)",
				[]string{"cn", "mail"},
			)
			_ = results
			_ = err
		}
	})

	b.Run("SearchWithAttributes", func(b *testing.B) {
		attributeSets := [][]string{
			{"cn"},
			{"cn", "mail"},
			{"cn", "mail", "description", "userAccountControl"},
			{"*"}, // All attributes
		}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			attrs := attributeSets[i%len(attributeSets)]
			results, err := client.SearchWithAttributes(
				context.Background(),
				"(objectClass=user)",
				attrs,
			)
			_ = results
			_ = err
		}
	})
}

// BenchmarkCacheOperations benchmarks caching operations
func BenchmarkCacheOperations(b *testing.B) {
	b.Run("UserCacheOperations", func(b *testing.B) {
		cache := NewUserCache(&CacheConfig{
			MaxSize: 1000,
			TTL:     5 * time.Minute,
		})

		users := make([]*User, 100)
		for i := range users {
			users[i] = &User{
				DN:       fmt.Sprintf("cn=user%d,ou=users,dc=example,dc=com", i),
				CN:       fmt.Sprintf("user%d", i),
				Username: fmt.Sprintf("user%d", i),
				Email:    fmt.Sprintf("user%d@example.com", i),
			}
		}

		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			i := 0
			for pb.Next() {
				user := users[i%len(users)]
				if i%3 == 0 {
					cache.Set(user.DN, user)
				} else {
					cache.Get(user.DN)
				}
				i++
			}
		})
	})

	b.Run("GroupCacheOperations", func(b *testing.B) {
		cache := NewGroupCache(&GroupCacheConfig{
			MaxSize: 500,
			TTL:     5 * time.Minute,
		})

		groups := make([]*Group, 50)
		for i := range groups {
			groups[i] = &Group{
				DN:          fmt.Sprintf("cn=group%d,ou=groups,dc=example,dc=com", i),
				CN:          fmt.Sprintf("group%d", i),
				Description: fmt.Sprintf("Group %d", i),
			}
		}

		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			i := 0
			for pb.Next() {
				group := groups[i%len(groups)]
				if i%4 == 0 {
					cache.Set(group.DN, group)
				} else {
					cache.Get(group.DN)
				}
				i++
			}
		})
	})

	b.Run("CacheEviction", func(b *testing.B) {
		cache := NewUserCache(&CacheConfig{
			MaxSize: 10, // Small cache to trigger evictions
			TTL:     1 * time.Minute,
		})

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			user := &User{
				DN:       fmt.Sprintf("cn=user%d,ou=users,dc=example,dc=com", i),
				Username: fmt.Sprintf("user%d", i),
			}
			cache.Set(user.DN, user)
		}
	})
}

// BenchmarkConcurrentOperations benchmarks concurrent operations
func BenchmarkConcurrentOperations(b *testing.B) {
	b.Run("ConcurrentAuthentication", func(b *testing.B) {
		mock := NewMockLDAPConn()
		SetupTestUsersAndGroups(mock)

		client := &LDAP{
			config: &Config{
				Server: "ldap://test:389",
				BaseDN: "dc=example,dc=com",
			},
			logger: slog.Default(),
		}

		credentials := []struct {
			username string
			password string
		}{
			{"admin", "password"},
			{"user1", "password"},
			{"user2", "password"},
		}

		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			i := 0
			for pb.Next() {
				cred := credentials[i%len(credentials)]
				success, err := client.AuthenticateUser(context.Background(), cred.username, cred.password)
				_ = success
				_ = err
				i++
			}
		})
	})

	b.Run("ConcurrentUserLookup", func(b *testing.B) {
		mock := NewMockLDAPConn()
		SetupTestUsersAndGroups(mock)

		client := &LDAP{
			config: &Config{
				Server: "ldap://test:389",
				BaseDN: "dc=example,dc=com",
			},
			logger: slog.Default(),
		}

		usernames := []string{"admin", "user1", "user2", "user3"}

		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			i := 0
			for pb.Next() {
				username := usernames[i%len(usernames)]
				user, err := client.FindUserByUsername(context.Background(), username)
				_ = user
				_ = err
				i++
			}
		})
	})

	b.Run("ConcurrentGroupMembership", func(b *testing.B) {
		mock := NewMockLDAPConn()
		SetupTestUsersAndGroups(mock)

		client := &LDAP{
			config: &Config{
				Server: "ldap://test:389",
				BaseDN: "dc=example,dc=com",
			},
			logger: slog.Default(),
		}

		userDNs := []string{
			"cn=admin,ou=users,dc=example,dc=com",
			"cn=user1,ou=users,dc=example,dc=com",
			"cn=user2,ou=users,dc=example,dc=com",
		}
		groupDN := "cn=admins,ou=groups,dc=example,dc=com"

		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			i := 0
			for pb.Next() {
				userDN := userDNs[i%len(userDNs)]
				isMember, err := client.IsUserInGroup(context.Background(), userDN, groupDN)
				_ = isMember
				_ = err
				i++
			}
		})
	})
}

// BenchmarkMemoryOperations benchmarks memory-intensive operations
func BenchmarkMemoryOperations(b *testing.B) {
	b.Run("LargeResultSet", func(b *testing.B) {
		mock := NewMockLDAPConn()

		// Create large result set
		largeResults := make([]*User, 1000)
		for i := range largeResults {
			largeResults[i] = &User{
				DN:          fmt.Sprintf("cn=user%d,ou=users,dc=example,dc=com", i),
				CN:          fmt.Sprintf("User %d", i),
				Username:    fmt.Sprintf("user%d", i),
				Email:       fmt.Sprintf("user%d@example.com", i),
				Description: fmt.Sprintf("Test user %d with some description", i),
			}
		}

		client := &LDAP{
			config: &Config{
				Server: "ldap://test:389",
				BaseDN: "dc=example,dc=com",
			},
			logger: slog.Default(),
		}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			users, err := client.SearchUsers(context.Background(), "(objectClass=user)")
			_ = users
			_ = err
		}
	})

	b.Run("DeepGroupHierarchy", func(b *testing.B) {
		mock := NewMockLDAPConn()

		// Create nested groups
		groups := make([]*Group, 100)
		for i := range groups {
			groups[i] = &Group{
				DN:          fmt.Sprintf("cn=group%d,ou=groups,dc=example,dc=com", i),
				CN:          fmt.Sprintf("group%d", i),
				Description: fmt.Sprintf("Group %d description", i),
			}
			if i > 0 {
				groups[i].Members = []string{groups[i-1].DN}
			}
		}

		client := &LDAP{
			config: &Config{
				Server: "ldap://test:389",
				BaseDN: "dc=example,dc=com",
			},
			logger: slog.Default(),
		}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			groups, err := client.SearchGroups(context.Background(), "(objectClass=group)")
			_ = groups
			_ = err
		}
	})
}

// BenchmarkContextOperations benchmarks context-related operations
func BenchmarkContextOperations(b *testing.B) {
	b.Run("ContextWithTimeout", func(b *testing.B) {
		mock := NewMockLDAPConn()
		SetupTestUsersAndGroups(mock)

		client := &LDAP{
			config: &Config{
				Server: "ldap://test:389",
				BaseDN: "dc=example,dc=com",
			},
			logger: slog.Default(),
		}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
			user, err := client.FindUserByUsername(ctx, "admin")
			_ = user
			_ = err
			cancel()
		}
	})

	b.Run("ContextCancellation", func(b *testing.B) {
		mock := NewMockLDAPConn()
		SetupTestUsersAndGroups(mock)

		client := &LDAP{
			config: &Config{
				Server: "ldap://test:389",
				BaseDN: "dc=example,dc=com",
			},
			logger: slog.Default(),
		}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			ctx, cancel := context.WithCancel(context.Background())
			go func() {
				time.Sleep(1 * time.Millisecond)
				cancel()
			}()

			user, err := client.FindUserByUsername(ctx, "admin")
			_ = user
			_ = err
		}
	})
}

// BenchmarkErrorHandling benchmarks error handling scenarios
func BenchmarkErrorHandling(b *testing.B) {
	b.Run("NonExistentUser", func(b *testing.B) {
		mock := NewMockLDAPConn()
		SetupTestUsersAndGroups(mock)

		client := &LDAP{
			config: &Config{
				Server: "ldap://test:389",
				BaseDN: "dc=example,dc=com",
			},
			logger: slog.Default(),
		}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			user, err := client.FindUserByUsername(context.Background(), fmt.Sprintf("nonexistent%d", i))
			_ = user
			_ = err
		}
	})

	b.Run("InvalidDN", func(b *testing.B) {
		mock := NewMockLDAPConn()
		SetupTestUsersAndGroups(mock)

		client := &LDAP{
			config: &Config{
				Server: "ldap://test:389",
				BaseDN: "dc=example,dc=com",
			},
			logger: slog.Default(),
		}

		invalidDNs := []string{
			"invalid-dn",
			"cn=,ou=users,dc=example,dc=com",
			"malformed=dn=structure",
		}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			dn := invalidDNs[i%len(invalidDNs)]
			user, err := client.FindUserByDN(context.Background(), dn)
			_ = user
			_ = err
		}
	})
}

// BenchmarkResourceCleanup benchmarks resource cleanup operations
func BenchmarkResourceCleanup(b *testing.B) {
	b.Run("ConnectionClose", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			mock := NewMockLDAPConn()
			err := mock.Close()
			_ = err
		}
	})

	b.Run("CacheCleanup", func(b *testing.B) {
		cache := NewUserCache(&CacheConfig{
			MaxSize: 1000,
			TTL:     1 * time.Millisecond, // Short TTL for cleanup
		})

		// Fill cache
		for i := 0; i < 100; i++ {
			user := &User{
				DN:       fmt.Sprintf("cn=user%d,ou=users,dc=example,dc=com", i),
				Username: fmt.Sprintf("user%d", i),
			}
			cache.Set(user.DN, user)
		}

		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			cache.Cleanup()
		}
	})
}

// BenchmarkMetricsCollection benchmarks metrics collection operations
func BenchmarkMetricsCollection(b *testing.B) {
	b.Run("OperationMetrics", func(b *testing.B) {
		metrics := NewPerformanceMetrics()

		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			i := 0
			for pb.Next() {
				duration := time.Duration(i%1000) * time.Microsecond
				metrics.RecordOperation("search", duration, i%10 != 0)
				i++
			}
		})
	})

	b.Run("CounterMetrics", func(b *testing.B) {
		counter := NewOperationCounter()

		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			for pb.Next() {
				counter.Increment("ldap_operations_total")
			}
		})
	})
}

// Helper function to simulate various workload patterns
func BenchmarkWorkloadPatterns(b *testing.B) {
	b.Run("ReadHeavyWorkload", func(b *testing.B) {
		mock := NewMockLDAPConn()
		SetupTestUsersAndGroups(mock)

		client := &LDAP{
			config: &Config{
				Server: "ldap://test:389",
				BaseDN: "dc=example,dc=com",
			},
			logger: slog.Default(),
		}

		// 90% reads, 10% writes
		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			i := 0
			for pb.Next() {
				if i%10 < 9 {
					// Read operation
					user, err := client.FindUserByUsername(context.Background(), fmt.Sprintf("user%d", i%100))
					_ = user
					_ = err
				} else {
					// Write operation (simulate)
					success, err := client.AuthenticateUser(context.Background(), "admin", "password")
					_ = success
					_ = err
				}
				i++
			}
		})
	})

	b.Run("WriteHeavyWorkload", func(b *testing.B) {
		mock := NewMockLDAPConn()
		SetupTestUsersAndGroups(mock)

		client := &LDAP{
			config: &Config{
				Server: "ldap://test:389",
				BaseDN: "dc=example,dc=com",
			},
			logger: slog.Default(),
		}

		// 30% reads, 70% writes
		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			i := 0
			for pb.Next() {
				if i%10 < 3 {
					// Read operation
					user, err := client.FindUserByUsername(context.Background(), fmt.Sprintf("user%d", i%100))
					_ = user
					_ = err
				} else {
					// Write operation (simulate)
					success, err := client.AuthenticateUser(context.Background(), fmt.Sprintf("user%d", i%100), "password")
					_ = success
					_ = err
				}
				i++
			}
		})
	})
}

// ReportBenchmarkResults reports benchmark results with memory statistics
func ReportBenchmarkResults(b *testing.B, operation string) {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)

	b.ReportMetric(float64(m.Alloc)/1024/1024, "MB_alloc")
	b.ReportMetric(float64(m.TotalAlloc)/1024/1024, "MB_total_alloc")
	b.ReportMetric(float64(m.Sys)/1024/1024, "MB_sys")
	b.ReportMetric(float64(m.NumGC), "num_gc")
}

// Initialize benchmark environment
func init() {
	// Set GOMAXPROCS for consistent benchmark results
	runtime.GOMAXPROCS(runtime.NumCPU())
}